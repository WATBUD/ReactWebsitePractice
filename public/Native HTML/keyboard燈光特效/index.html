<style>body {-webkit-app-region: drag;
	position: absolute;
	z-index:99;
	width:800px; 
	height:25px;
	top:0px;
	 color: white; background-color: black;}</style>
<script src="dat.gui.min.js"></script>
<script id="utility.js">
CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
	if (typeof radius === 'undefined') {radius = 0;}
	this.beginPath();
	this.moveTo(x + radius, y);
	this.lineTo(x + width - radius, y);
	this.quadraticCurveTo(x + width, y, x + width, y + radius);
	this.lineTo(x + width, y + height - radius);
	this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	this.lineTo(x + radius, y + height);
	this.quadraticCurveTo(x, y + height, x, y + height - radius);
	this.lineTo(x, y + radius);
	this.quadraticCurveTo(x, y, x + radius, y);
	this.closePath();
	return this;
}
</script>
<script id="coordinate.js">
//[0]:左上角 [1]:右上角 [2]:右下角 [3]:左下角
var keyboard = 
//ESC~PAUSE
[[{"x":416,"y":187},{"x":473,"y":187},{"x":473,"y":244},{"x":416,"y":244}],
[{"x":547,"y":187},{"x":604,"y":187},{"x":604,"y":244},{"x":547,"y":244}],
[{"x":613,"y":187},{"x":670,"y":187},{"x":670,"y":244},{"x":613,"y":244}],
[{"x":679,"y":187},{"x":736,"y":187},{"x":736,"y":244},{"x":679,"y":244}],
[{"x":746,"y":187},{"x":803,"y":187},{"x":803,"y":244},{"x":746,"y":244}],
[{"x":844,"y":187},{"x":901,"y":187},{"x":901,"y":244},{"x":844,"y":244}],
[{"x":911,"y":187},{"x":968,"y":187},{"x":968,"y":244},{"x":911,"y":244}],
[{"x":977,"y":187},{"x":1034,"y":187},{"x":1034,"y":244},{"x":977,"y":244}],
[{"x":1042,"y":187},{"x":1099,"y":187},{"x":1099,"y":244},{"x":1042,"y":244}],
[{"x":1141,"y":187},{"x":1198,"y":187},{"x":1198,"y":244},{"x":1141,"y":244}],
[{"x":1207,"y":187},{"x":1264,"y":187},{"x":1264,"y":244},{"x":1207,"y":244}],
[{"x":1273,"y":187},{"x":1330,"y":187},{"x":1330,"y":244},{"x":1273,"y":244}],
[{"x":1339,"y":187},{"x":1396,"y":187},{"x":1396,"y":244},{"x":1339,"y":244}],
[{"x":1409,"y":187},{"x":1466,"y":187},{"x":1466,"y":244},{"x":1409,"y":244}],
[{"x":1475,"y":187},{"x":1532,"y":187},{"x":1532,"y":244},{"x":1475,"y":244}],
[{"x":1541,"y":187},{"x":1598,"y":187},{"x":1598,"y":244},{"x":1541,"y":244}],
//period~
[{"x":416,"y":253},{"x":473,"y":253},{"x":473,"y":310},{"x":416,"y":310}],[{"x":481,"y":253},{"x":538,"y":253},{"x":538,"y":310},{"x":481,"y":310}],[{"x":547,"y":253},{"x":604,"y":253},{"x":604,"y":310},{"x":547,"y":310}],[{"x":613,"y":253},{"x":670,"y":253},{"x":670,"y":310},{"x":613,"y":310}],[{"x":679,"y":253},{"x":736,"y":253},{"x":736,"y":310},{"x":679,"y":310}],[{"x":745,"y":253},{"x":802,"y":253},{"x":802,"y":310},{"x":745,"y":310}],[{"x":811,"y":253},{"x":868,"y":253},{"x":868,"y":310},{"x":811,"y":310}],[{"x":877,"y":253},{"x":934,"y":253},{"x":934,"y":310},{"x":877,"y":310}],[{"x":943,"y":253},{"x":1000,"y":253},{"x":1000,"y":310},{"x":943,"y":310}],[{"x":1009,"y":253},{"x":1066,"y":253},{"x":1066,"y":310},{"x":1009,"y":310}],[{"x":1075,"y":253},{"x":1132,"y":253},{"x":1132,"y":310},{"x":1075,"y":310}],[{"x":1141,"y":253},{"x":1198,"y":253},{"x":1198,"y":310},{"x":1141,"y":310}],[{"x":1208,"y":253},{"x":1265,"y":253},{"x":1265,"y":310},{"x":1208,"y":310}],[{"x":1272,"y":253},{"x":1399,"y":253},{"x":1399,"y":310},{"x":1272,"y":310}],[{"x":1409,"y":253},{"x":1466,"y":253},{"x":1466,"y":310},{"x":1409,"y":310}],[{"x":1475,"y":253},{"x":1532,"y":253},{"x":1532,"y":310},{"x":1475,"y":310}],[{"x":1539,"y":253},{"x":1596,"y":253},{"x":1596,"y":310},{"x":1539,"y":310}],[{"x":1610,"y":253},{"x":1667,"y":253},{"x":1667,"y":310},{"x":1610,"y":310}],[{"x":1676,"y":253},{"x":1733,"y":253},{"x":1733,"y":310},{"x":1676,"y":310}],[{"x":1741,"y":253},{"x":1798,"y":253},{"x":1798,"y":310},{"x":1741,"y":310}],[{"x":1808,"y":253},{"x":1865,"y":253},{"x":1865,"y":310},{"x":1808,"y":310}],[{"x":416,"y":319},{"x":509,"y":319},{"x":509,"y":376},{"x":416,"y":376}],[{"x":514,"y":319},{"x":571,"y":319},{"x":571,"y":376},{"x":514,"y":376}],[{"x":581,"y":319},{"x":638,"y":319},{"x":638,"y":376},{"x":581,"y":376}],[{"x":646,"y":319},{"x":703,"y":319},{"x":703,"y":376},{"x":646,"y":376}],[{"x":712,"y":319},{"x":769,"y":319},{"x":769,"y":376},{"x":712,"y":376}],[{"x":779,"y":319},{"x":836,"y":319},{"x":836,"y":376},{"x":779,"y":376}],[{"x":844,"y":319},{"x":901,"y":319},{"x":901,"y":376},{"x":844,"y":376}],[{"x":910,"y":319},{"x":967,"y":319},{"x":967,"y":376},{"x":910,"y":376}],[{"x":977,"y":319},{"x":1034,"y":319},{"x":1034,"y":376},{"x":977,"y":376}],[{"x":1042,"y":319},{"x":1099,"y":319},{"x":1099,"y":376},{"x":1042,"y":376}],[{"x":1108,"y":319},{"x":1165,"y":319},{"x":1165,"y":376},{"x":1108,"y":376}],[{"x":1174,"y":319},{"x":1231,"y":319},{"x":1231,"y":376},{"x":1174,"y":376}],[{"x":1240,"y":319},{"x":1297,"y":319},{"x":1297,"y":376},{"x":1240,"y":376}],[{"x":1306,"y":319},{"x":1397,"y":319},{"x":1397,"y":376},{"x":1306,"y":376}],[{"x":1409,"y":319},{"x":1466,"y":319},{"x":1466,"y":376},{"x":1409,"y":376}],[{"x":1474,"y":319},{"x":1531,"y":319},{"x":1531,"y":376},{"x":1474,"y":376}],[{"x":1540,"y":319},{"x":1597,"y":319},{"x":1597,"y":376},{"x":1540,"y":376}],[{"x":1611,"y":319},{"x":1668,"y":319},{"x":1668,"y":376},{"x":1611,"y":376}],[{"x":1676,"y":319},{"x":1733,"y":319},{"x":1733,"y":376},{"x":1676,"y":376}],[{"x":1742,"y":319},{"x":1799,"y":319},{"x":1799,"y":376},{"x":1742,"y":376}],[{"x":1809,"y":319},{"x":1866,"y":319},{"x":1866,"y":446},{"x":1809,"y":446}],[{"x":416,"y":384},{"x":524,"y":384},{"x":524,"y":441},{"x":416,"y":441}],[{"x":533,"y":384},{"x":590,"y":384},{"x":590,"y":441},{"x":533,"y":441}],[{"x":599,"y":384},{"x":656,"y":384},{"x":656,"y":441},{"x":599,"y":441}],[{"x":665,"y":384},{"x":722,"y":384},{"x":722,"y":441},{"x":665,"y":441}],[{"x":731,"y":384},{"x":788,"y":384},{"x":788,"y":441},{"x":731,"y":441}],[{"x":797,"y":384},{"x":854,"y":384},{"x":854,"y":441},{"x":797,"y":441}],[{"x":863,"y":384},{"x":920,"y":384},{"x":920,"y":441},{"x":863,"y":441}],[{"x":929,"y":384},{"x":986,"y":384},{"x":986,"y":441},{"x":929,"y":441}],[{"x":995,"y":384},{"x":1052,"y":384},{"x":1052,"y":441},{"x":995,"y":441}],[{"x":1061,"y":384},{"x":1118,"y":384},{"x":1118,"y":441},{"x":1061,"y":441}],[{"x":1127,"y":384},{"x":1184,"y":384},{"x":1184,"y":441},{"x":1127,"y":441}],[{"x":1193,"y":384},{"x":1250,"y":384},{"x":1250,"y":441},{"x":1193,"y":441}],[{"x":1259,"y":384},{"x":1396,"y":384},{"x":1396,"y":441},{"x":1259,"y":441}],[{"x":1611,"y":384},{"x":1668,"y":384},{"x":1668,"y":441},{"x":1611,"y":441}],[{"x":1676,"y":384},{"x":1733,"y":384},{"x":1733,"y":441},{"x":1676,"y":441}],[{"x":1741,"y":384},{"x":1798,"y":384},{"x":1798,"y":441},{"x":1741,"y":441}],[{"x":416,"y":450},{"x":556,"y":450},{"x":556,"y":507},{"x":416,"y":507}],[{"x":566,"y":450},{"x":623,"y":450},{"x":623,"y":507},{"x":566,"y":507}],[{"x":633,"y":450},{"x":690,"y":450},{"x":690,"y":507},{"x":633,"y":507}],[{"x":698,"y":450},{"x":755,"y":450},{"x":755,"y":507},{"x":698,"y":507}],[{"x":764,"y":450},{"x":821,"y":450},{"x":821,"y":507},{"x":764,"y":507}],[{"x":831,"y":450},{"x":888,"y":450},{"x":888,"y":507},{"x":831,"y":507}],[{"x":896,"y":450},{"x":953,"y":450},{"x":953,"y":507},{"x":896,"y":507}],[{"x":963,"y":450},{"x":1020,"y":450},{"x":1020,"y":507},{"x":963,"y":507}],[{"x":1028,"y":450},{"x":1085,"y":450},{"x":1085,"y":507},{"x":1028,"y":507}],[{"x":1094,"y":450},{"x":1151,"y":450},{"x":1151,"y":507},{"x":1094,"y":507}],[{"x":1160,"y":450},{"x":1217,"y":450},{"x":1217,"y":507},{"x":1160,"y":507}],[{"x":1227,"y":450},{"x":1396,"y":450},{"x":1396,"y":507},{"x":1227,"y":507}],[{"x":1475,"y":450},{"x":1532,"y":450},{"x":1532,"y":507},{"x":1475,"y":507}],[{"x":1611,"y":450},{"x":1668,"y":450},{"x":1668,"y":507},{"x":1611,"y":507}],[{"x":1676,"y":450},{"x":1733,"y":450},{"x":1733,"y":507},{"x":1676,"y":507}],[{"x":1741,"y":450},{"x":1798,"y":450},{"x":1798,"y":507},{"x":1741,"y":507}],[{"x":1809,"y":450},{"x":1866,"y":450},{"x":1866,"y":577},{"x":1809,"y":577}],[{"x":416,"y":517},{"x":508,"y":517},{"x":508,"y":574},{"x":416,"y":574}],[{"x":514,"y":517},{"x":571,"y":517},{"x":571,"y":574},{"x":514,"y":574}],[{"x":581,"y":517},{"x":673,"y":517},{"x":673,"y":574},{"x":581,"y":574}],[{"x":680,"y":517},{"x":1067,"y":517},{"x":1067,"y":574},{"x":680,"y":574}],[{"x":1075,"y":517},{"x":1167,"y":517},{"x":1167,"y":574},{"x":1075,"y":574}],[{"x":1174,"y":517},{"x":1231,"y":517},{"x":1231,"y":574},{"x":1174,"y":574}],[{"x":1241,"y":517},{"x":1298,"y":517},{"x":1298,"y":574},{"x":1241,"y":574}],[{"x":1306,"y":517},{"x":1398,"y":517},{"x":1398,"y":574},{"x":1306,"y":574}],[{"x":1409,"y":517},{"x":1466,"y":517},{"x":1466,"y":574},{"x":1409,"y":574}],[{"x":1475,"y":517},{"x":1532,"y":517},{"x":1532,"y":574},{"x":1475,"y":574}],[{"x":1541,"y":517},{"x":1598,"y":517},{"x":1598,"y":574},{"x":1541,"y":574}],[{"x":1610,"y":517},{"x":1737,"y":517},{"x":1737,"y":574},{"x":1610,"y":574}],[{"x":1743,"y":517},{"x":1800,"y":517},{"x":1800,"y":574},{"x":1743,"y":574}],

//LED123~M1M2
[{"x":1619,"y":181},{"x":1631,"y":181},{"x":1631,"y":193},{"x":1619,"y":193}],
[{"x":1619,"y":201},{"x":1631,"y":201},{"x":1631,"y":213},{"x":1619,"y":213}],
[{"x":1619,"y":221},{"x":1631,"y":221},{"x":1631,"y":233},{"x":1619,"y":233}],
[{"x":1657,"y":178},{"x":1714,"y":178},{"x":1714,"y":235},{"x":1657,"y":235}],
[{"x":1786,"y":178},{"x":1843,"y":178},{"x":1843,"y":235},{"x":1786,"y":235}]
]
var keycodes = [
    "Escape","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","PrintScreen","ScrollLock","Pause","Backquote","Digit1","Digit2","Digit3","Digit4","Digit5","Digit6","Digit7","Digit8","Digit9","Digit0",
    "Minus","Equal","Backspace","Insert","Home","PageUp","NumLock","NumpadDivide","NumpadMultiply","NumpadSubtract",
    "Tab","KeyQ","KeyW","KeyE","KeyR","KeyT","KeyY","KeyU","KeyI","KeyO","KeyP","BracketLeft","BracketRight","Backslash","Delete","End","PageDown","Numpad7","Numpad8","Numpad9","NumpadAdd",
    "CapsLock","KeyA","KeyS","KeyD","KeyF","KeyG","KeyH","KeyJ","KeyK","KeyL","Semicolon","Quote","Enter","Numpad4","Numpad5","Numpad6",
    "ShiftLeft","KeyZ","KeyX","KeyC","KeyV","KeyB","KeyN","KeyM","Comma","Period","Slash","ShiftRight","ArrowUp","Numpad1","Numpad2","Numpad3","NumpadEnter",
    "ControlLeft","OSLeft","AltLeft","Space","AltRight","Function","ContextMenu","ControlRight","ArrowLeft","ArrowDown","ArrowRight","Numpad0","NumpadDecimal"
	];

var mouse = [
//Bottom
[{"x":25 ,"y":0},{"x":45,"y":0},{"x":45,"y":20},{"x":25,"y":20}],
[{"x":23 ,"y":20},{"x":43,"y":20},{"x":43,"y":40},{"x":23,"y":40}],
[{"x":20 ,"y":40},{"x":40,"y":40},{"x":40,"y":60},{"x":20,"y":60}],
[{"x":15 ,"y":70},{"x":35,"y":70},{"x":35,"y":90},{"x":15,"y":90}],
[{"x":10,"y":100},{"x":30,"y":100},{"x":30,"y":120},{"x":10,"y":120}],
[{"x":8 ,"y":130},{"x":28,"y":130},{"x":28,"y":150},{"x":8,"y":150}],
[{"x":5 ,"y":160},{"x":25,"y":160},{"x":25,"y":180},{"x":5,"y":180}],
[{"x":0 ,"y":190},{"x":20,"y":190},{"x":20,"y":210},{"x":0,"y":210}],
[{"x":0 ,"y":220},{"x":20,"y":220},{"x":20,"y":240},{"x":0,"y":240}],
[{"x":5 ,"y":250},{"x":25,"y":250},{"x":25,"y":270},{"x":5,"y":270}],
[{"x":10 ,"y":280},{"x":30,"y":280},{"x":30,"y":300},{"x":10,"y":300}],
[{"x":15 ,"y":310},{"x":35,"y":310},{"x":35,"y":330},{"x":15,"y":330}],
[{"x":25 ,"y":340},{"x":45,"y":340},{"x":45,"y":360},{"x":25,"y":360}],
[{"x":45 ,"y":370},{"x":65,"y":370},{"x":65,"y":390},{"x":45,"y":390}],
[{"x":70 ,"y":380},{"x":90,"y":380},{"x":90,"y":400},{"x":70,"y":400}],

[{"x":95 ,"y":385},{"x":115,"y":385},{"x":115,"y":405},{"x":95,"y":405}],

[{"x":120 ,"y":380},{"x":140,"y":380},{"x":140,"y":400},{"x":120,"y":400}],
[{"x":145 ,"y":370},{"x":165,"y":370},{"x":165,"y":390},{"x":145,"y":390}],
[{"x":165 ,"y":340},{"x":185,"y":340},{"x":185,"y":360},{"x":165,"y":360}],
[{"x":175 ,"y":310},{"x":195,"y":310},{"x":195,"y":330},{"x":175,"y":330}],
[{"x":180 ,"y":280},{"x":200,"y":280},{"x":200,"y":300},{"x":180,"y":300}],
[{"x":185 ,"y":250},{"x":205,"y":250},{"x":205,"y":270},{"x":185,"y":270}],
[{"x":190 ,"y":220},{"x":210,"y":220},{"x":210,"y":240},{"x":190,"y":240}],
[{"x":190 ,"y":190},{"x":210,"y":190},{"x":210,"y":210},{"x":190,"y":210}],
[{"x":185 ,"y":160},{"x":205,"y":160},{"x":205,"y":180},{"x":185,"y":180}],
[{"x":182 ,"y":130},{"x":202,"y":130},{"x":201,"y":150},{"x":182,"y":150}],
[{"x":180,"y":100},{"x":200,"y":100},{"x":200,"y":120},{"x":180,"y":120}],
[{"x":175 ,"y":70},{"x":195,"y":70},{"x":195,"y":90},{"x":175,"y":90}],
[{"x":170 ,"y":40},{"x":190,"y":40},{"x":190,"y":60},{"x":170,"y":60}],
[{"x":167 ,"y":20},{"x":187,"y":20},{"x":187,"y":40},{"x":167,"y":40}],
[{"x":165 ,"y":0},{"x":185,"y":0},{"x":185,"y":20},{"x":165,"y":20}],

//Scroll

[{"x":102 ,"y":50},{"x":122,"y":50},{"x":122,"y":70},{"x":102,"y":70}],
//Logo
[{"x":70 ,"y":280},{"x":160,"y":280},{"x":160,"y":340},{"x":70,"y":340}]

];
</script>
<img src="keyboard.png" id="keyboard.png" style="display: none;">
<img src="mouse.png" id="mouse.png" style="display: none;">
<script>
var imageKeyboard = document.getElementById("keyboard.png");
var imageMouse    = document.getElementById("mouse.png");
</script>
<script id="device.js">
class Device {
	constructor(device_type, coordinates, keycodes, image) {
		this.type = device_type;
		if (!keycodes) keycodes = [];

		var x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;
		for (let i=0; i<coordinates.length; ++i)
			for (let j=0; j<4; ++j) {
				x1 = Math.min(x1, coordinates[i][j].x);
				y1 = Math.min(y1, coordinates[i][j].y);
				x2 = Math.max(x2, coordinates[i][j].x);
				y2 = Math.max(y2, coordinates[i][j].y);
			}

		this.position = {
			x      : -14,
			y      : -24,
			width  : image.width,
			height : image.height,
		}

		this.region = {
			x      : 0,
			y      : 0,
			width  : x2 - x1,
			height : y2 - y1,
		};

		this.lights = new Array(coordinates.length);
		for (let i=0; i<coordinates.length; ++i) {
			var light = {};
			light.x1 = coordinates[i][0].x - x1;
			light.y1 = coordinates[i][0].y - y1;
			light.x2 = coordinates[i][2].x - x1;
			light.y2 = coordinates[i][2].y - y1;
			light.x = (light.x1 + light.x2) / 2;
			light.y = (light.y1 + light.y2) / 2;
//			light.code = (i < keycodes.length) ? keycodes[i] : '';
			this.lights[i] = light;
		}

		// given name, return light index
		var array = new Array(keycodes.length);
		for (let i=0; i<keycodes.length; ++i)
			array[i] = [keycodes[i], i];
		this.keycodemap = new Map(array);

		this.image = image;
	}
	move(dx, dy) {
		this.position.x += dx;
		this.position.y += dy;
		this.region.x += dx;
		this.region.y += dy;
		for (let light of this.lights) {
			light.x1 += dx;
			light.y1 += dy;
			light.x2 += dx;
			light.y2 += dy;
			light.x  += dx;
			light.y  += dy;
		}
	}
	draw(ctx, colors, selects) {
		ctx.roundRect(this.position.x, this.position.y, this.position.width, this.position.height, 16);
		ctx.fillStyle = 'rgb(32,32,32)';
		ctx.fill();

		if (this.image)
			ctx.drawImage(this.image, this.position.x, this.position.y);

		for (let i=0; i<this.lights.length; ++i) {
			var light = this.lights[i];
			ctx.roundRect(light.x1, light.y1, light.x2 - light.x1, light.y2 - light.y1, 6);
			if (colors && colors[i]) {
				ctx.fillStyle = 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ', 0.6)';
				ctx.fill();
			}
			if (selects && selects[i]) {
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'rgba(204,172,0,1.0)';
				ctx.stroke();
			}
		}
	}
}
</script>
<script id="color.js">
function hsl2rgb(h, s, l) {
	if (!isFinite(h)) h = 0;
	if (!isFinite(s)) s = 0;
	if (!isFinite(l)) l = 0;

	h /= 60;
	if (h < 0) h = 6 - (-h % 6);
	h %= 6;

	s = Math.max(0, Math.min(1, s / 100));
	l = Math.max(0, Math.min(1, l / 100));

	var c = (1 - Math.abs((2 * l) - 1)) * s;
	var x = c * (1 - Math.abs((h % 2) - 1));

	if      (h < 1) {r = c; g = x; b = 0;}
	else if (h < 2) {r = x; g = c; b = 0;}
	else if (h < 3) {r = 0; g = c; b = x;}
	else if (h < 4) {r = 0; g = x; b = c;}
	else if (h < 5) {r = x; g = 0; b = c;}
	else            {r = c; g = 0; b = x;}

	var m = l - c / 2;
	var r = Math.round((r + m) * 255);
	var g = Math.round((g + m) * 255);
	var b = Math.round((b + m) * 255);
	return [r, g, b];
}

function assigncolor(color, color1) {
	for (let i=0; i<3; ++i)
		color[i] = color1[i];
}

function addcolor(color, color1) {
	for (let i=0; i<3; ++i)
		color[i] += color1[i];
}

function addscaledcolor(color, color1, ratio) {
	for (let i=0; i<3; ++i)
		color[i] += color1[i] * ratio;
}

function mulcolor(color, ratio) {
	for (let i=0; i<3; ++i)
		color[i] *= ratio;
}

function softcolor(color, ratio) {
	ratio = 1 - Math.abs(ratio * 2 - 1);	// linear mountain
	ratio = 1 - Math.pow(2, -5 * ratio);	// easeOutExpo
	mulcolor(color, ratio);
}

function interpolatecolor(color, color1, color2, ratio) {
	for (let i=0; i<3; ++i)
		color[i] = color1[i] * (1 - ratio) + color2[i] * ratio;
}
</script>
<script id="effect.js">
class Effect {
	constructor() {
		this.opacity = 0.5;
		Effect.prototype.blend_mode = 'overlap';
		this.defaultcolors = [
			[255,0,0],
			[0,255,0],
			[0,255,255],
			[0,0,255],
			[255,0,255]
			// hsl2rgb( 45, 60, 60),
			// hsl2rgb(135, 60, 60),
			// hsl2rgb(225, 60, 60),
			// hsl2rgb(315, 60, 60),
			// [192,192,192]
		];
		this.defaultscales = [
			0, 0.2, 0.4, 0.6, 0.8
		];
		this.colors = new Array(this.defaultcolors.length);
		for (let i=0; i<this.defaultcolors.length; ++i) {
			this.colors[i] = [0,0,0];
			assigncolor(this.colors[i], this.defaultcolors[i]);
		}
		this.scales = this.defaultscales.slice(0);
		this.color_number = 2;
		this.use_scales = false;
	}
	initGUI() {
		this.gui = new dat.GUI({hideable: false});
		this.gui.hide();
		this.folder = this.gui.addFolder('colors');
		this.folder.open();
		this.folder.add(this, "opacity").min(0).max(1).step(0.1);
		this.guicolors = new Array(this.defaultcolors.length);
		this.guiscales = new Array(this.defaultscales.length);
		for (let i=0; i<this.color_number; ++i) {
			this.guicolors[i] = this.folder.addColor(this.colors, i, this.colors[i]).name('color ' + (i+1));
			if (this.use_scales) this.guiscales[i] = this.folder.add(this.scales, i, this.scales[i]).name('scale ' + (i+1)).min(0).max(1).step(.1);
		}
	}
	createColor() {
		if (this.color_number >= this.defaultcolors.length) return;
		var i = this.color_number++;
		assigncolor(this.colors[i], this.defaultcolors[i]);
		this.scales[i] = this.defaultscales[i];

		this.guicolors[i] = this.folder.addColor(this.colors, i, this.colors[i]).name('color ' + (i+1));
		if (this.use_scales) this.guiscales[i] = this.folder.add(this.scales, i, this.scales[i]).name('scale ' + (i+1)).min(0).max(1).step(.1);
	}
	removeColor() {
		if (this.color_number <= 1) return;
		var i = --this.color_number;

		this.folder.remove(this.guicolors[i]);
		if (this.use_scales) this.folder.remove(this.guiscales[i]);
	}
	toggleColorScale() {
		this.use_scales = !this.use_scales;
		if (this.use_scales) {
			for (let i=0; i<this.color_number; ++i)
				this.folder.remove(this.guicolors[i]);
			for (let i=0; i<this.color_number; ++i) {
				this.guicolors[i] = this.folder.addColor(this.colors, i, this.colors[i]).name('color ' + (i+1));
				this.guiscales[i] = this.folder.add(this.scales, i, this.scales[i]).name('scale ' + (i+1)).min(0).max(1).step(.1);
			}
		} else {
			for (let i=0; i<this.color_number; ++i)
				this.folder.remove(this.guiscales[i]);
		}
	}
	getColor(result, scale, loop) {
		scale -= Math.floor(scale);	// [0, 1)
		if (!this.use_scales) {
			if (!this.gradient) {
				scale *= this.color_number;
				var index = Math.floor(scale);
				assigncolor(result, this.colors[index]);
			} else {
				if (loop) scale *= this.color_number;
				else      scale *= (this.color_number - 1);
				if (loop) scale -= 0.5;		// align to !gradient
				var index = Math.floor(scale);
				var color1 = this.colors[(index + this.color_number) % this.color_number];
				var color2 = this.colors[(index + 1) % this.color_number];
				var ratio = scale - index;
				interpolatecolor(result, color1, color2, ratio);
			}
		} else {
			var min_index = 0;
			var min_scale = 1.1;
			var max_index = 0;
			var max_scale = 0;
			for (let i=0; i<this.color_number; ++i) {
				if (this.scales[i] >= max_scale)
					max_scale = this.scales[max_index = i];
				if (this.scales[i] < min_scale)
					min_scale = this.scales[min_index = i];
			}

			var lower_index = -1;
			var lower_scale = 0;
			var upper_index = this.color_number;
			var upper_scale = 1;
			for (let i=0; i<this.color_number; ++i)
				if (this.scales[i] <= scale) {
					if (this.scales[i] >= lower_scale)
						lower_scale = this.scales[lower_index = i];
				} else {
					if (this.scales[i] < upper_scale)
						upper_scale = this.scales[upper_index = i];
				}

			if (loop) {
				if (lower_index == -1)
					lower_scale = this.scales[lower_index = max_index] - 1;
				if (upper_index == this.color_number)
					upper_scale = this.scales[upper_index = min_index] + 1;
			} else {
				if (lower_index == -1)
					lower_scale = this.scales[lower_index = min_index];
				if (upper_index == this.color_number)
					upper_scale = this.scales[upper_index = max_index];
			}

			if (!this.gradient) {
				assigncolor(result, this.colors[lower_index]);
			} else {
				if (lower_scale == upper_scale)
					assigncolor(result, this.colors[lower_index]);
				else {
					var color1 = this.colors[lower_index];
					var color2 = this.colors[upper_index];
					var ratio = (scale - lower_scale) / (upper_scale - lower_scale);
					interpolatecolor(result, color1, color2, ratio);
				}
			}
		}
	}
	blendColor(result, color) {
		if (Effect.prototype.blend_mode === 'add')
			addscaledcolor(result, color, this.opacity);
		else if (Effect.prototype.blend_mode === 'overlap')
			interpolatecolor(result, result, color, this.opacity);
	}
	event(light) {
		// empty
	}
	init(region) {
		// empty
	}
	center(x, y) {
		// empty
	}
	draw(ctx) {
		// empty
	}
}

class LinearBand extends Effect {
	constructor() {
		super();
		this.description = "直線彩帶";
		this.speed = 10;
		this.bandwidth = 100;
		this.angle = 0;		// degree
		this.gradient = false;

		this.position = 0;
	}
	update() {
		this.position += this.speed;
		this.position %= this.bandwidth * this.color_number;
	}
	render(lights, region, outputs, selects) {
		var theta = 2 * Math.PI * this.angle / 360;
		var dx =  Math.cos(theta);
		var dy = -Math.sin(theta);
		if (Math.abs(dx) < 1e-5) dx = 0;
		if (Math.abs(dy) < 1e-5) dy = 0;

		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var d = light.x * dx + light.y * dy;
			var scale = (d - this.position) / this.bandwidth / this.color_number;
			var output = [0,0,0];
			this.getColor(output, scale, true);
			this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "bandwidth").min(50).max(500).step(50);
		this.gui.add(this, "angle").min(0).max(360).step(30);
		this.gui.add(this, "gradient");
	}
}

class ConicBand extends Effect {
	constructor() {
		super();
		this.description = "擴散彩帶";
		this.speed = 10;
		this.bandwidth = 100;
		this.direction = true;
		this.gradient = false;

		this.position = 0;
	}
	init(region) {
		this.x = region.width  / 2;
		this.y = region.height / 2;
	}
	center(x, y) {
		this.x = x;
		this.y = y;
	}
	update() {
		this.position += this.speed * (this.direction ? +1 : -1);
		this.position %= this.bandwidth * this.color_number;
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var d = Math.hypot(light.x - this.x, light.y - this.y);
			var scale = (d - this.position) / this.bandwidth / this.color_number;
			var output = [0,0,0];
			this.getColor(output, scale, true);
			this.blendColor(outputs[i], output);
		}
	}
	draw(ctx) {
		super.draw(ctx);
		ctx.strokeStyle = "lightgreen";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.arc(this.x, this.y, 8, 0, 2*Math.PI);
		ctx.stroke();
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "bandwidth").min(50).max(500).step(50);
		this.gui.add(this, "direction");
		this.gui.add(this, "gradient");
	}
}

class RadialBand extends Effect {
	constructor() {
		super();
		this.description = "旋轉彩帶";
		this.speed = 10;
		this.direction = true;
		this.gradient = false;

		this.angle = 0;								// degree
		this.bandangle = 360 / this.color_number;	// degree
	}
	init(region) {
		this.x = region.width  / 2;
		this.y = region.height / 2;
	}
	center(x, y) {
		this.x = x;
		this.y = y;
	}
	update() {
		this.angle += this.speed * (this.direction ? -1 : +1);
		this.angle %= 360;
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var t = Math.atan2(-(light.y - this.y), light.x - this.x);
			t = t / (2 * Math.PI) * 360;
			this.bandangle = 360 / this.color_number;
			var scale = (t - this.angle) / this.bandangle / this.color_number;
			var output = [0,0,0];
			this.getColor(output, scale, true);
			this.blendColor(outputs[i], output);
		}
	}
	draw(ctx) {
		super.draw(ctx);
		ctx.strokeStyle = "lightgreen";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.arc(this.x, this.y, 8, 0, 2*Math.PI);
		ctx.stroke();
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "direction");
		this.gui.add(this, "gradient");
	}
}

class GlobalBand extends Effect {
	constructor() {
		super();
		this.description = "全域彩帶";
		this.bandwidth = 100;
		this.speed = 10;
		this.gradient = false;

		this.position = 0;
	}
	update() {
		this.position += this.speed;
		this.position %= this.bandwidth * this.color_number;
	}
	render(lights, region, outputs, selects) {
		var output = [0,0,0];
		var scale = this.position / this.bandwidth / this.color_number;
		this.getColor(output, scale, true);

		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "gradient");
	}
}

class LinearWave extends Effect {
	constructor() {
		super();
		this.description = "直線波紋(晴朗)";
		this.speed = 10;
		this.bandwidth = 100;
		this.gap = 100;
		this.width = (this.bandwidth + this.gap) * this.color_number - this.gap;
		this.bump = 0;
		this.angle = 0;

		this.fps = 60;
		this.randomspeed = 0;
		this.gradient = false;
		this.soft = false;
		this.fixed = false;
		this.bidirectional = false;

		this.frame = 0;
		this.animations = [];	// cicular queue
	}
	event(light) {
		this.animations.push({
			position : 0,
			direction : +1,
			bump : 0,
			x : light.x,
			y : light.y,
			life : 1,
		});
		if (!this.bidirectional) return;
		this.animations.push({
			position : 0,
			direction : -1,
			bump : 0,
			x : light.x,
			y : light.y,
			life : 1,
		});
	}
	update(region, devices) {
		this.width = (this.bandwidth + this.gap) * this.color_number - this.gap;
		var theta = 2 * Math.PI * this.angle / 360;
		var dx =  Math.cos(theta);
		var dy = -Math.sin(theta);
		if (Math.abs(dx) < 1e-5) dx = 0;
		if (Math.abs(dy) < 1e-5) dy = 0;
		var d = region.x * dx + region.y * dy;
		var rx = region.width * dx;
		var ry = region.height * dy;
		var dmin = d + Math.min(rx, 0) + Math.min(ry, 0);
		var dmax = d + Math.max(rx, 0) + Math.max(ry, 0);

		for (let animation of this.animations) {
			if (!animation.life) continue;
			animation.position += this.speed;
			var d = (animation.x * dx + animation.y * dy) * animation.direction;
			var D = (animation.direction === +1) ? dmax: -dmin;
			if (d + animation.position > D + this.width) {
				animation.bump++;
				animation.position = 0;
				animation.x = region.x + region.width * (rx * animation.direction > 0);
				animation.y = region.y + region.height * (ry *animation.direction > 0);
				animation.direction *= -1;
			}
			if (animation.bump > this.bump)
				animation.life--;
		}
		while (this.animations.length > 0
			&& !this.animations[0].life)
//			&& this.animations[0].position - this.width > region.diameter)
			this.animations.shift();

		if (this.randomspeed > 0) {
			this.frame ++;
			this.frame %= Math.ceil(1000 / this.fps / this.randomspeed);
			if (this.frame == 0) {
				for (let i=0; i<devices.length; ++i) {
					var lights = devices[i].lights;
					if (lights.length == 0) continue;
					var index = Math.floor(Math.random() * lights.length);
					this.event(lights[index]);
				}
			}
		}
	}
	render(lights, region, outputs, selects) {
		var theta = 2 * Math.PI * this.angle / 360;
		var dx =  Math.cos(theta);
		var dy = -Math.sin(theta);
		if (Math.abs(dx) < 1e-5) dx = 0;
		if (Math.abs(dy) < 1e-5) dy = 0;

		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var output = [0,0,0];
			var has_output = false;
			for (let animation of this.animations) {
				if (!animation.life) continue;
				var d = (light.x - animation.x) * dx
				      + (light.y - animation.y) * dy;
				d *= animation.direction;
				if (d < 0) continue;
				if (!(d >= animation.position - this.width && d < animation.position)) continue;

				var position = d - (animation.position - this.width);
				var quotient = position / (this.bandwidth + this.gap);
				quotient = Math.floor(quotient);
				var residue = position - quotient * (this.bandwidth + this.gap);
				if (residue > this.bandwidth) continue;

				var color = [0,0,0];
				if (this.fixed) {
					var scale = (quotient + residue / this.bandwidth) / this.color_number;
					this.getColor(color, scale, false);
				} else {
					var D = Math.abs(region.width  * dx)
					      + Math.abs(region.height * dy);
					if (d >= D) continue;
					var scale = d / D;
					this.getColor(color, scale, false);
				}
				if (this.soft) {
					var ratio = residue / this.bandwidth;
					if (this.gap == 0) ratio = position / this.width;
					softcolor(color, ratio);
				}
				addcolor(output, color);
				has_output = true;
			}
			if (has_output)
				this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "bandwidth").min(50).max(500).step(50);
		this.gui.add(this, "gap").min(0).max(500).step(50);
		this.gui.add(this, "bump").min(0).max(5).step(1);
		this.gui.add(this, "angle").min(0).max(360).step(30);
		this.gui.add(this, "randomspeed").min(0).max(5).step(1);
		this.gui.add(this, "gradient");
		this.gui.add(this, "soft");
		this.gui.add(this, "fixed");
		this.gui.add(this, "bidirectional");
	}
}

class ConicWave extends Effect {
	constructor() {
		super();
		this.description = "擴散波紋";
		this.speed = 10;
		this.bandwidth = 100;
		this.gap = 100;
		this.width = (this.bandwidth + this.gap) * this.color_number - this.gap;

		this.fps = 60;
		this.randomspeed = 0;
		this.gradient = false;
		this.soft = false;
		this.fixed = false;

		this.frame = 0;
		this.animations = [];	// cicular queue
	}
	event(light) {
		this.animations.push({
			position : 0,
			x : light.x,
			y : light.y,
		});
	}
	update(region, devices) {
		this.width = (this.bandwidth + this.gap) * this.color_number - this.gap;

		for (let animation of this.animations)
			animation.position += this.speed;
		while (this.animations.length > 0
			&& this.animations[0].position - this.width > region.diameter)
			this.animations.shift();

		if (this.randomspeed > 0) {
			this.frame ++;
			this.frame %= Math.ceil(1000 / this.fps / this.randomspeed);
			if (this.frame == 0) {
				for (let i=0; i<devices.length; ++i) {
					var lights = devices[i].lights;
					if (lights.length == 0) continue;
					var index = Math.floor(Math.random() * lights.length);
					this.event(lights[index]);
				}
			}
		}
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var output = [0,0,0];
			var has_output = false;
			for (let animation of this.animations) {
				var d = Math.hypot(light.x - animation.x, light.y - animation.y);
				if (!(d >= animation.position - this.width && d < animation.position)) continue;

				var position = d - (animation.position - this.width);
				var quotient = position / (this.bandwidth + this.gap);
				quotient = Math.floor(quotient);
				var residue = position - quotient * (this.bandwidth + this.gap);
				if (residue > this.bandwidth) continue;

				var color = [0,0,0];
				if (this.fixed) {
					var scale = (quotient + residue / this.bandwidth) / this.color_number;
					this.getColor(color, scale, false);
				} else {
					var D = region.diameter;
					if (d >= D) continue;
					var scale = d / D;
					this.getColor(color, scale, false);
				}
				if (this.soft) {
					var ratio = residue / this.bandwidth;
					if (this.gap == 0) ratio = position / this.width;
					softcolor(color, ratio);
				}
				addcolor(output, color);
				has_output = true;
			}
			if (has_output)
				this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "bandwidth").min(50).max(500).step(50);
		this.gui.add(this, "gap").min(0).max(500).step(50);
		this.gui.add(this, "randomspeed").min(0).max(5).step(1);
		this.gui.add(this, "gradient");
		this.gui.add(this, "soft");
		this.gui.add(this, "fixed");
	}
}

class GlobalWave extends Effect {
	constructor() {
		super();
		this.description = "全域波紋(呼吸)";
		this.speed = 1;
		this.bandwidth = 100;
		this.gap = 100;
		this.gradient = false;
		this.soft = false;

		this.position = 0;
	}
	update() {
		this.position += this.speed;
		this.position %= (this.bandwidth + this.gap) * this.color_number;
	}
	render(lights, region, outputs, selects) {
		var output = [0,0,0];

		var quotient = this.position / (this.bandwidth + this.gap);
		quotient = Math.floor(quotient);
		var residue = this.position - quotient * (this.bandwidth + this.gap);
		if (residue > this.bandwidth) return;

		var scale = (quotient + residue / this.bandwidth) / this.color_number;
		this.getColor(output, scale, false);

		if (this.soft) {
			var ratio = residue / this.bandwidth;
			if (this.gap == 0) ratio = this.position / this.bandwidth / this.color_number;
			softcolor(output, ratio);
		}

		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "bandwidth").min(50).max(500).step(50);
		this.gui.add(this, "gap").min(0).max(500).step(50);
		this.gui.add(this, "gradient");
		this.gui.add(this, "soft");
	}
}

class Rain extends Effect {
	constructor() {
		super();
		this.description = "下雨";
		this.speed = 10;
		this.number = 10;
		this.angle = 0;
	}
	init(region) {
		this.particles = new Array(this.number);
		for (let i=0; i<this.particles.length; ++i) {
			this.particles[i] = {
				x: region.width  * Math.random(),
				y: region.height * Math.random(),
				color: this.colors[i % this.color_number],
			};
		}
		this.color_index = this.number % this.color_number;
	}
	nextcolor() {
		this.color_index++;
		this.color_index %= this.color_number;
		return this.colors[this.color_index];
	}
	update(region) {
		var theta = 2 * Math.PI * this.angle / 360;
		var dx =  Math.cos(theta);
		var dy = -Math.sin(theta);
		if (Math.abs(dx) < 1e-5) dx = 0;
		if (Math.abs(dy) < 1e-5) dy = 0;

		for (let i=0; i<this.number; ++i) {
			var p = this.particles[i];
			p.x += dx * this.speed;
			p.y += dy * this.speed;
			if (p.x < 0) {
				p.x = region.width;
				p.y = region.height * Math.random();
				p.color = this.nextcolor();
			} else if (p.x > region.width) {
				p.x = 0;
				p.y = region.height * Math.random();
				p.color = this.nextcolor();
			} else if (p.y < 0) {
				p.x = region.width  * Math.random();
				p.y = region.height;
				p.color = this.nextcolor();
			} else if (p.y > region.height) {
				p.x = region.width  * Math.random();
				p.y = 0;
				p.color = this.nextcolor();
			}
		}
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var output = [0,0,0];
			var has_output = false;
			for (let k=0; k<this.number; ++k) {
				var p = this.particles[k];
				if (p.x >= light.x1 && p.x <= light.x2
				 && p.y >= light.y1 && p.y <= light.y2) {
//					addcolor(output, p.color);
					assigncolor(output, p.color);
					has_output = true;
				}
			}
			if (has_output)
				this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "number").min(1).max(10).step(1);
		this.gui.add(this, "angle").min(0).max(360).step(30);
	}
}

class Fire extends Effect {
	constructor() {
		super();
		this.description = "火焰";
//		this.speed = 10;
		this.fire = 0.5;
		this.gradient = true;

//		this.defaultcolors[4] = [255, 255, 128];
//		this.defaultcolors[3] = [255, 255, 64];
//		this.defaultcolors[2] = [255, 255, 32];
//		this.defaultcolors[1] = [255, 32, 0];
//		this.defaultcolors[0] = [32, 32, 0]
//		for (let i=0; i<this.defaultcolors.length; ++i)
//			assigncolor(this.colors[i], this.defaultcolors[i]);
	}
	init(region) {
		this.size = 50;	// KEY WIDTH & HEIGHT
		this.X = Math.ceil(region.width / this.size);
		this.Y = Math.ceil(region.height / this.size);
		this.array = new Array(this.Y + 2);
		for (let y=0; y<this.array.length; ++y)
			this.array[y] = new Float32Array(this.X + 2).fill(0);
	}
	update() {
		if (!this.array) return;
//		for (let x=1; x<=this.X; ++x) {
//			this.array[this.Y][x] = (Math.random() < this.fire) ? 0.999 : 0;
//		}

		for (let x=1; x<=this.X; ++x) {
			if (Math.random() < this.fire)
				this.array[this.Y][x] += 0.05;
			else
				this.array[this.Y][x] -= 0.05;
			if (this.array[this.Y][x] >= 1)
				this.array[this.Y][x] = 1 - 1e-5;
			if (this.array[this.Y][x] < 0)
				this.array[this.Y][x] = 0;
		}

		for (let y=this.Y-1; y>=1; --y) {
			for (let x=1; x<=this.X; ++x) {
				var value = 0;
				value += this.array[y][x];
				value += this.array[y+1][x];
				value += this.array[y+1][x-1];
				value += this.array[y+1][x+1];
				if (x == 1 || x == this.Y)
					this.array[y][x] = value / 3;
				else
					this.array[y][x] = value / 4;
			}
		}

//		for (let y=this.Y+1; y>=1; --y) {
//			for (let x=1; x<=this.X; ++x) {
//				this.array[y-1][x]   += this.array[y][x] * 0.1;
//				this.array[y-1][x-1] += this.array[y][x] * 0.1;
//				this.array[y-1][x+1] += this.array[y][x] * 0.1;
//				this.array[y][x] *= 0.66;
//			}
//		}
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var output = [255, 32, 0];
			var x = (light.x - region.x) / this.size + 0.5;
			var y = (light.y - region.y) / this.size + 0.5;
			var x0 = x | 0;  var x1 = x0 + 1;
			var y0 = y | 0;  var y1 = y0 + 1;
			var s1 = x - x0; var s0 = 1 - s1;
			var t1 = y - y0; var t0 = 1 - t1;
			if (!(x0 >= 0 && x1 <= this.X+1
			   && y0 >= 0 && y1 <= this.Y+1)) continue;
			var scale = s0 * (t0 * this.array[y0][x0] + t1 * this.array[y1][x0])
			          + s1 * (t0 * this.array[y0][x1] + t1 * this.array[y1][x1]);
//			var scale = this.array[y0][x0];
//			this.getColor(output, scale, false);
			mulcolor(output, scale);
			this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
//		this.gui.add(this, "speed").min(1).max(10).step(1);
		this.gui.add(this, "fire").min(0).max(1).step(0.1);
//		this.gui.add(this, "gradient");
	}
}

class Keyin extends Effect {
	constructor() {
		super();
		this.description = "鍵盤按鍵(星光)";
		this.fps  = 60;
		this.time = 0.5;	// second
		this.maxlife = Math.ceil(this.time * 1000 / this.fps);
		this.radius = 0;
		this.randomspeed = 0;
		this.gradient = false;
		this.soft = false;
		this.separate = false;

		this.frame = 0;
		this.color_index = 0;
		this.animations = [];	// cicular queue
	}
	event(light) {
		this.animations.push({
			life  : 0,
			light : light,
			color : this.colors[this.color_index],
		});
		this.color_index = (this.color_index + 1) % this.color_number;
	}
	update(region, devices) {
		this.maxlife = Math.ceil(this.time * 1000 / this.fps);
		for (let animation of this.animations)
			animation.life++;
		while (this.animations.length > 0 && this.animations[0].life > this.maxlife)
			this.animations.shift();

		if (this.randomspeed > 0) {
			this.frame ++;
			this.frame %= Math.ceil(1000 / this.fps / this.randomspeed);
			if (this.frame == 0) {
				for (let i=0; i<devices.length; ++i) {
					var lights = devices[i].lights;
					if (lights.length == 0) continue;
					var index = Math.floor(Math.random() * lights.length);
					this.event(lights[index]);
				}
			}
		}
	}
	render(lights, region, outputs, selects) {
		for (let i=0; i<lights.length; ++i) {
			if (!selects[i]) continue;
			var light = lights[i];
			var output = [0,0,0];
			var has_output = false;
			for (let animation of this.animations) {
				var d = Math.hypot(light.x - animation.light.x, light.y - animation.light.y);
				if (d > this.radius) continue;
				if (this.separate) {
					assigncolor(output, animation.color);
				} else {
					var scale = animation.life / this.maxlife;
					this.getColor(output, scale, false);
				}
				if (this.soft) {
					var ratio = animation.life / this.maxlife;
					softcolor(output, ratio);
				}
				has_output = true;
			}
			if (has_output)
				this.blendColor(outputs[i], output);
		}
	}
	initGUI() {
		super.initGUI();
		this.gui.add(this, "time").min(0.5).max(3).step(0.5);
		this.gui.add(this, "radius").min(0).max(300).step(50);
		this.gui.add(this, "randomspeed").min(0).max(10).step(1);
		this.gui.add(this, "gradient");
		this.gui.add(this, "soft");
		this.gui.add(this, "separate");
	}
}
</script>
<div id="output" style="font-size: 12pt; text-align: left; height: 1.5em;"></div>
<script>
var output = document.getElementById("output");
</script>
<script id="manager.js">
class Manager {
	constructor() {
		this.devices = [];
		this.effects = [];
		this.outputs = [];	// device -> [r,g,b] array
		this.selects = [];	// (device, effect) -> bool array
		this.blends = [];	// effect -> bool

		this.region = {
			x        : 0,
			y        : 0,
			width    : 0,
			height   : 0,
			diameter : 0,
		};

		this.effect_index = -1;
		this.effect = null;
		this.device_index = -1;
		this.device = null;

		this.show_effect = null;
	}
	reset() {
		this.outputs = new Array(this.devices.length);
		for (let i=0; i<this.devices.length; ++i) {
			this.outputs[i] = new Array(this.devices[i].lights.length);
			for (let j=0; j<this.outputs[i].length; ++j) {
				this.outputs[i][j] = [0,0,0];
			}
		}

		this.selects = new Array(this.devices.length);
		for (let i=0; i<this.devices.length; ++i) {
			this.selects[i] = new Array(this.effects.length);
			for (let j=0; j<this.effects.length; ++j) {
				this.selects[i][j] = new Array(this.devices[i].lights.length).fill(true);
			}
		}

		this.blends = new Array(this.effects.length).fill(true);
	}
	updateRegion() {
		var x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;
		for (let device of this.devices) {
			x1 = Math.min(x1, device.region.x);
			y1 = Math.min(y1, device.region.y);
			x2 = Math.max(x2, device.region.x + device.region.width);
			y2 = Math.max(y2, device.region.y + device.region.height);
		}
		this.region.x = x1;
		this.region.y = y1;
		this.region.width  = x2 - x1;
		this.region.height = y2 - y1;
		this.region.diameter = Math.hypot(x2 - x1, y2 - y1);
	}
	updateEffects() {
		for (let i=0; i<this.effects.length; ++i)
			this.effects[i].init(this.region);
	}
	setBlendMode(blend_mode) {
		Effect.prototype.blend_mode = blend_mode;
	}
	pushDevice(device) {
		this.devices.push(device);

		var outputs = new Array(device.lights.length);
		for (let j=0; j<outputs.length; ++j)
			outputs[j] = [0,0,0];
		this.outputs.push(outputs);

		var selects = new Array(this.effects.length);
		for (let j=0; j<selects.length; ++j)
			selects[j] = new Array(device.lights.length).fill(true);
		this.selects.push(selects);

		// screen position
		var x = this.devices.length * 20;
		var y = this.devices.length * 20;
		device.move(x, y);
		this.updateRegion();
		this.updateEffects();
	}
	popDevice() {
		this.devices.pop();
		this.outputs.pop();
		this.selects.pop();
		this.updateRegion();
		this.updateEffects();
	}
	pushEffect(effect) {
		effect.init(this.region);
		this.effects.push(effect);
		for (let i=0; i<this.devices.length; ++i) {
			var selects = new Array(this.devices[i].lights.length).fill(true);
			this.selects[i].push(selects);
		}
		this.blends.push(true);

		if (this.effect_index < 0)
			this.effect = this.effects[this.effect_index = 0];

		effect.initGUI();
		this.showGUI();
	}
	popEffect() {
		if (this.effects.length == 0) return;

		this.effects.pop();
		for (let i=0; i<this.devices.length; ++i)
			this.selects[i].pop();
		this.blends.pop();

		if (this.effect_index >= this.effects.length)
			this.effect_index--;
		if (this.effect_index < 0)
			this.effect = null;
		else
			this.effect = this.effects[this.effect_index];

		this.showGUI();
	}
	insertEffect(effect) {
		if (this.effect_index < 0) this.effect_index = 0;

		effect.init(this.region);
		this.effects.splice(this.effect_index, 0, effect);
		for (let i=0; i<this.devices.length; ++i) {
			var selects = new Array(this.devices[i].lights.length).fill(true);
			this.selects[i].splice(this.effect_index, 0, selects);
		}
		this.blends.splice(this.effect_index, 0, true);

		this.effect = this.effects[this.effect_index];

		effect.initGUI();
		this.showGUI();
	}
	insertAfterEffect(effect) {
		this.effect_index++;
		this.insertEffect(effect);
	}
	deleteEffect() {
		if (this.effects.length == 0) return;

		this.effects.splice(this.effect_index, 1);
		for (let i=0; i<this.devices.length; ++i)
			this.selects[i].splice(this.effect_index, 1);
		this.blends.splice(this.effect_index, 1);

		if (this.effect_index >= this.effects.length)
			this.effect_index--;
		if (this.effect_index < 0)
			this.effect = null;
		else
			this.effect = this.effects[this.effect_index];

		this.showGUI();
	}
	toggleEffect() {
		if (!(this.effect_index >= 0 && this.effect_index < this.effects.length)) return;
		this.blends[this.effect_index] = !this.blends[this.effect_index];
		this.showGUI();
	}
	selectEffect(index) {
		if (!(index >= 0 && index < this.effects.length)) return;
		this.effect = this.effects[this.effect_index = index];
		this.showGUI();
	}
	changeEffect(diff) {
		var index = this.effect_index + diff;
		if (index < 0) index = 0;
		if (index >= this.effects.length - 1) index = this.effects.length - 1;
		if (index == this.effect_index) return;
		this.effect = this.effects[this.effect_index = index];
		this.showGUI();
	}
//	initGUI() {
//		for (let effect of this.effects) effect.initGUI();
//		this.effect_index = 0;
//		this.effect = this.effects[this.effect_index];
//		this.showGUI();
//	}
	showGUI() {
		if (this.show_effect)
			this.show_effect.gui.hide();
		if (this.effect_index < 0) {
			this.show_effect = null;
		} else {
			this.show_effect = this.effect;
			this.show_effect.gui.show();
		}
		this.showEffectNames();
	}
	showEffectNames() {
		if (this.effects.length == 0) {
			output.innerHTML = '請新增燈效';
			return;
		}
		var str = '';
		for (let i=0; i<this.effects.length; ++i) {
			var effect = this.effects[i];
			var blend = this.blends[i];
			if (effect == this.effect) str += '<strong><span style="color: gold;">'
			if (!blend) str += '<span style="opacity: 0.3;">';
			str += ' 🠊 ';
			str += effect.description;
//			str += ' ' + effect.constructor.name;
			if (!blend) str += '</span>';
			if (effect == this.effect) str += '</span></strong>'
		}
		output.innerHTML = str;
	}
	event(device_type, keycode) {
		
		console.log('device_type:'+device_type+' keycode:'+keycode);

		for (let i=0; i<this.devices.length; ++i) {
			var device = this.devices[i];
			if (device.type != device_type) continue;
			if (device.type === 'keyboard') {
				var index = device.keycodemap.get(keycode);
				if (!index) continue;
			} else if (device.type === 'mouse') {
				var index = device.lights.length - 1;
				if (index < 0) continue;
			}
			var light = device.lights[index];
			for (let j=0; j<this.effects.length; ++j)
				this.effects[j].event(light);
		}
	}
	center(x, y) {
		if (!this.effect) return;
		this.effect.center(x, y);
	}
	update() {
		for (let effect of this.effects)
			effect.update(this.region, this.devices);
	}
	render() {
		for (let i=0; i<this.devices.length; ++i)
			for (let j=0; j<this.outputs[i].length; ++j)
				assigncolor(this.outputs[i][j], [0,0,0]);

		if (!this.effect) return;
		if (!this.blends[this.effect_index]) return;
		for (let i=0; i<this.devices.length; ++i) {
			var device = this.devices[i];
			var outputs = this.outputs[i];
			var selects = this.selects[i][this.effect_index];
			this.effect.render(device.lights, this.region, outputs, selects);
		}
	}
	draw(ctx) {
		for (let i=0; i<this.devices.length; ++i) {
			var device = this.devices[i];
			var outputs = this.outputs[i];
			var selects = this.selects[i][this.effect_index];
			device.draw(ctx, outputs, selects);
		}
		if (this.effect) this.effect.draw(ctx);
	}
	renderAll() {
		for (let i=0; i<this.devices.length; ++i)
			for (let j=0; j<this.outputs[i].length; ++j)
				assigncolor(this.outputs[i][j], [0,0,0]);

		for (let i=0; i<this.devices.length; ++i) {
			var device = this.devices[i];
			var outputs = this.outputs[i];
			for (let j=0; j<this.effects.length; ++j) {
				var effect = this.effects[j];
				var selects = this.selects[i][j];
				var blend = this.blends[j];
				if (!blend) continue;
				effect.render(device.lights, this.region, outputs, selects);
			}
		}
	}
	drawAll(ctx) {
		for (let i=0; i<this.devices.length; ++i) {
			var device = this.devices[i];
			var outputs = this.outputs[i];
			device.draw(ctx, outputs, null);
		}
	}
//	flush() {
//		for (let i=0; i<this.devices.length; ++i)
//			for (let j=0; j<this.outputs[i].length; ++j) {
//				this.outputs[i][j][0] = Math.min(255, this.outputs[i][j][0]);
//				this.outputs[i][j][1] = Math.min(255, this.outputs[i][j][1]);
//				this.outputs[i][j][2] = Math.min(255, this.outputs[i][j][2]);
//			}
//	}
	selectAll(bool) {
		if (!(this.effect_index >= 0 && this.effect_index < this.effects.length)) return;
		for (let i=0; i<this.devices.length; ++i) {
			var select = this.selects[i][this.effect_index];
			for (let j=0; j<select.length; ++j)
				select[j] = bool;
		}
	}
	selectXY(x, y, bool) {
		if (!(this.effect_index >= 0 && this.effect_index < this.effects.length)) return;
		for (let i=0; i<this.devices.length; ++i) {
			var select = this.selects[i][this.effect_index];
			for (let j=0; j<select.length; ++j) {
				var light = this.devices[i].lights[j];
				if (x >= light.x1 && x <= light.x2
				 && y >= light.y1 && y <= light.y2)
					select[j] = bool;
			}
		}
	}
	selectSegment(x1, y1, x2, y2, bool) {
		if (!(this.effect_index >= 0 && this.effect_index < this.effects.length)) return;
		for (let i=0; i<this.devices.length; ++i) {
			var select = this.selects[i][this.effect_index];
			for (let j=0; j<select.length; ++j) {
				var light = this.devices[i].lights[j];
				if (x1 < light.x1 && x2 < light.x1) continue;
				if (x1 > light.x2 && x2 > light.x2) continue;
				if (y1 < light.y1 && y2 < light.y1) continue;
				if (y1 > light.y2 && y2 > light.y2) continue;
				var dx = x2 - x1;
				var dy = y2 - y1;
				var c = x1 * y2 - x2 * y1;
				var c1 = light.x1 * dy - light.y1 * dx - c;
				var c2 = light.x1 * dy - light.y2 * dx - c;
				var c3 = light.x2 * dy - light.y1 * dx - c;
				var c4 = light.x2 * dy - light.y2 * dx - c;
				if (c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) continue;
				if (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0) continue;
				select[j] = bool;
			}
		}
	}
	selectRegion(x1, y1, x2, y2, bool) {
		if (!(this.effect_index >= 0 && this.effect_index < this.effects.length)) return;
		if (x1 > x2) [x1, x2] = [x2, x1];
		if (y1 > y2) [y1, y2] = [y2, y1];
		for (let i=0; i<this.devices.length; ++i) {
			var select = this.selects[i][this.effect_index];
			for (let j=0; j<select.length; ++j) {
				var light = this.devices[i].lights[j];
				if (!(light.x2 <= x1 || light.x1 >= x2
				   || light.y2 <= y1 || light.y1 >= y2))
					select[j] = bool;
			}
		}
	}
	holdDevice(x, y) {
		this.device_index = -1;
		this.device = null;
		for (let i=this.devices.length-1; i>=0; --i) {
			var position = this.devices[i].position;
			if (x >= position.x && x <= position.x + position.width
			 && y >= position.y && y <= position.y + position.height) {
				this.device_index = i;
				this.device = this.devices[i];
				return;
			}
		}
	}
	moveDevice(dx, dy) {
		if (!this.device) return;
		this.device.move(dx, dy);
		console.log('Device:'+this.device_index+' X:'+dx+' Y:'+dy);
		console.log('Device region X:'+this.device.region.x+' Device region Y:'+this.device.region.y);
		this.updateRegion();
	}
	releaseDevice(x, y) {
		this.device_index = -1;
		this.device = null;
		this.updateEffects();
	}
	createColor() {
		if (!this.effect) return;
		this.effect.createColor();
	}
	removeColor() {
		if (!this.effect) return;
		this.effect.removeColor();
	}
	toggleColorScale() {
		if (!this.effect) return;
		this.effect.toggleColorScale();
	}
}
</script>
<script id="init.js">
var manager = new Manager();

var images_count = 0;
var images = document.querySelectorAll("img");
for (let image of images) image.onload = init;

function init() {
	if (++images_count < images.length) return;
	manager.pushDevice(new Device('keyboard', keyboard, keycodes, imageKeyboard));
	manager.pushDevice(new Device('mouse', mouse, null, imageMouse));
//	manager.pushEffect(new LinearBand());
//	manager.pushEffect(new ConicBand());
//	manager.pushEffect(new RadialBand());
//	manager.pushEffect(new GlobalBand());
	manager.pushEffect(new LinearWave());
	manager.pushEffect(new ConicWave());
//	manager.pushEffect(new GlobalWave());
	manager.pushEffect(new Rain());
	manager.pushEffect(new Fire());
	manager.pushEffect(new Keyin());
}

document.addEventListener('keydown', function(e){
	manager.event('keyboard', e.code);
});
document.addEventListener('mousedown', function(e){
	if (e.target.constructor.name === 'HTMLCanvasElement')
		manager.event('mouse');
});

window.onkeydown = function(e) {
//	e.preventdefault();
//	e.stopPropagation();
	if      (e.code === 'ArrowUp')    {manager.removeColor(); return;}
	else if (e.code === 'ArrowDown')  {manager.createColor(); return;}
	else if (e.code === 'ArrowLeft')  {manager.changeEffect(-1); return;}
	else if (e.code === 'ArrowRight') {manager.changeEffect(+1); return;}
//	else if (e.code === 'KeyZ') {manager.toggleColorScale(); return;}
}
</script>
<style>canvas {border: 1px dashed lightgray;}</style>
<canvas id="canvas" width="980" height="300"></canvas>
<script id="animation.js">
	var canvas = document.getElementById("canvas");
	var ctx    = canvas.getContext('2d');

	var scale = 0.5;
	ctx.scale(scale, scale);

	var all = false;
	var draw = true;

	function update() {
		manager.update();
		all ? manager.renderAll() : manager.render();
		if (draw) {
			ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);
			all ? manager.drawAll(ctx) : manager.draw(ctx);
			drawSelectRegion(ctx);
		}
	}

	var id;
	window.onload = function() {
		if (!id) {id = setInterval(update, 10);}
		else     {clearInterval(id); id = 0;}
	}
</script>
<br><div id="fps"></div>
<script id="fps.js">
	var fps = document.getElementById('fps');
	var thisDate = 0, diffDate = 0;
	var lastDate = new Date();

	function simulation() {
		thisDate = new Date();
		diffDate = thisDate - lastDate;
		lastDate = thisDate;
		update();
	};

//	window.onload = function() {
//		setInterval(simulation, 10);
//		setInterval(function(){
//			fps.innerHTML = (1000 / diffDate).toFixed(1) + " fps";
//		},1000);
//	}
</script>
<button class="select" mode="selectNone"   >清除燈光</button>
<button class="toggle" mode="selectSegment">點選燈光</button>
<button class="toggle" mode="selectRegion" >框選燈光</button>
<button class="select" mode="selectAll"    >全選燈光</button>
|
<button class="toggle" mode="moveDevice"   >移動鍵盤滑鼠</button>
<button class="device" mode="pushDevice(keyboard)">新增鍵盤</button>
<button class="device" mode="pushDevice(mouse)"   >新增滑鼠</button>
<button class="device" mode="popDevice"           >移除設備</button>
|<br>
<button class="color" mode="createColor">減少色彩</button>
<button class="color" mode="removeColor">增加色彩</button>
<button class="color" mode="toggleColorScale">色彩播放速度編輯器切換</button>
|
<button class="effect" mode="changeEffect(-1)">上個燈效</button>
<button class="effect" mode="changeEffect(+1)">下個燈效</button>
<button class="effect" mode="toggleEffect">顯示/隱藏燈效</button>
<button class="effect" mode="deleteEffect">刪除燈效</button>
|<br>
<div class="effect" mode="insertAfterEffect" style="display: inline;">新增燈效：</div>
<br>
<input type="checkbox" id="all">顯示全部燈效</input>
<input type="radio" name="blend_mode" value="overlap">覆蓋模式</input>
<input type="radio" name="blend_mode" value="add"    >加法模式</input>
<br>
<input type="checkbox" id="draw">停止繪圖、維持計算、然後你可以測CPU rate</input>
<script id="button.js">
	var toggle_buttons = document.querySelectorAll("button.toggle");
	var button_mode = '';

	function toggleButton(button) {
		for (let b of toggle_buttons) if (b != button) b.style.borderStyle = '';
		if (button == null) return;
		if (button_mode == button.getAttribute('mode')) {
			button.style.borderStyle = '';
			button_mode = '';
		} else {
			button.style.borderStyle = 'inset';
			button_mode = button.getAttribute('mode');
		}
	}

	for (let button of toggle_buttons)
		button.onmousedown = function(e) {toggleButton(button);}

	var selectRegion = false;
	var x1 = 0, y1 = 0, x2 = 0, y2 = 0;

	function drawSelectRegion(ctx) {
		if (!selectRegion) return;
		ctx.lineWidth = 2;
		ctx.fillStyle = "rgba(128,128,128,0.3)";
		ctx.strokeStyle = "rgba(192,192,192,0.3)";
		ctx.beginPath();
		ctx.rect(x1, y1, x2 - x1, y2 - y1);
		ctx.fill();
		ctx.stroke();
	}

	var mouse_pressed = false;
//	canvas.tabIndex = 1;
	canvas.style.position = "relative";

	canvas.addEventListener('mousedown', function(e){
		mouse_pressed = true;
		x1 = x2 = Math.round(e.layerX / scale);
		y1 = y2 = Math.round(e.layerY / scale);
		if (button_mode === '') {
			manager.center(x1, y1);
		} else if (button_mode === 'selectSegment') {
			manager.selectSegment(x1, y1, x1, y1, true);
		} else if (button_mode === 'selectRegion') {
			selectRegion = true;
		} else if (button_mode === 'moveDevice') {
			manager.holdDevice(x1, y1);
		}
	});
	canvas.addEventListener('mouseup', function(e){
		if (!mouse_pressed) return;
		mouse_pressed = false;
		var xt = x2;
		var yt = y2;
		x2 = Math.round(e.layerX / scale);
		y2 = Math.round(e.layerY / scale);
		if (button_mode === 'selectSegment') {
			manager.selectSegment(xt, yt, x2, y2, true);
		} else if (button_mode === 'selectRegion') {
			manager.selectRegion(x1, y1, x2, y2, true);
			selectRegion = false;
		} else if (button_mode === 'moveDevice') {
			manager.moveDevice(x2 - xt, y2 - yt);
			manager.releaseDevice();
		}
	});
	canvas.addEventListener('mouseout', function(e){
		if (!mouse_pressed) return;
		mouse_pressed = false;
		var xt = x2;
		var yt = y2;
		var rect = canvas.getBoundingClientRect();
		x2 = Math.round((e.clientX - rect.left) / scale);
		y2 = Math.round((e.clientY - rect.top)  / scale);
		if (button_mode === 'selectSegment') {
			manager.selectSegment(xt, yt, x2, y2, true);
		} else if (button_mode === 'selectRegion') {
			manager.selectRegion(x1, y1, x2, y2, true);
			selectRegion = false;
		} else if (button_mode === 'moveDevice') {
			manager.moveDevice(x2 - xt, y2 - yt);
			manager.releaseDevice();
		}
	});
	canvas.addEventListener('mousemove', function(e){
		if (!mouse_pressed) return;
		var xt = x2;
		var yt = y2;
		x2 = Math.round(e.layerX / scale);
		y2 = Math.round(e.layerY / scale);
		if (button_mode === 'selectSegment') {
			manager.selectSegment(xt, yt, x2, y2, true);
		} else if (button_mode === 'moveDevice') {
			manager.moveDevice(x2 - xt, y2 - yt);
		}
	});

	var select_buttons = document.querySelectorAll("button.select");
	select_buttons[0].onmousedown = function(e) {manager.selectAll(false);}
	select_buttons[1].onmousedown = function(e) {manager.selectAll(true);}

	var device_buttons = document.querySelectorAll("button.device");
	device_buttons[0].onmousedown = function(e) {manager.pushDevice(new Device('keyboard', keyboard, keycodes, imageKeyboard));}
	device_buttons[1].onmousedown = function(e) {manager.pushDevice(new Device('mouse', mouse, null, imageMouse));}
	device_buttons[2].onmousedown = function(e) {manager.popDevice();}

	var color_buttons = document.querySelectorAll("button.color");
	color_buttons[0].onmousedown = function(e) {manager.removeColor();}
	color_buttons[1].onmousedown = function(e) {manager.createColor();}
	color_buttons[2].onmousedown = function(e) {manager.toggleColorScale();}

	var effect_buttons = document.querySelectorAll("button.effect");
	effect_buttons[0].onmousedown = function(e) {manager.changeEffect(-1);}
	effect_buttons[1].onmousedown = function(e) {manager.changeEffect(+1);}
	effect_buttons[2].onmousedown = function(e) {manager.toggleEffect();}
	effect_buttons[3].onmousedown = function(e) {manager.deleteEffect();}

	var script = document.querySelector("script#effect\\.js");
	var re = /class (.*) extends/g;
	var classes = [];
	for (let m; m = re.exec(script.innerHTML); ) classes.push(m[1]);
	var re = /this\.description \= "(.*)";/g;
	var descriptions = [];
	for (let m; m = re.exec(script.innerHTML); ) descriptions.push(m[1]);

	var div = document.querySelector("div.effect");
	for (let i=0; i<classes.length; ++i) {
		var classname = classes[i];
		var description = descriptions[i];
		var button = document.createElement('button');
		button.innerHTML = description + '<br>' + classname;
		button.onmousedown = function(e) {
			manager.insertAfterEffect(eval('new ' + classes[i] + '()'));
		}
		div.appendChild(button);
	}

	var radios = document.querySelectorAll('input[name=blend_mode]');
	for (let radio of radios)
		if (radio.value === manager.blend_mode)
			radio.checked = true;
	for (let radio of radios)
		radio.onchange = function(e) {manager.setBlendMode(e.target.value);}

	var checkbox = document.querySelector("input#all");
	checkbox.checked = all;
	for (let radio of radios) radio.disabled = !checkbox.checked;
	checkbox.onchange = function(e) {
		all = e.target.checked;
		for (let radio of radios) radio.disabled = !e.target.checked;
	}

	var checkbox = document.querySelector("input#draw");
	checkbox.checked = !draw;
	checkbox.onchange = function(e) {draw = !e.target.checked;}
</script>